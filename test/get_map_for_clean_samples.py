import os
import xml.etree.ElementTree as ET

from PIL import Image
from tqdm import tqdm

from utils.utils import get_classes
from utils.utils_map import get_coco_map, get_map
from yolo import YOLO

if __name__ == "__main__":
    '''
    Unlike AP (which is an area-based metric), Recall and Precision vary with the confidence threshold.
    By default, the Recall and Precision values calculated in this code correspond to a confidence threshold of 0.5.

    Due to the principle of mAP calculation, the network needs to obtain nearly all prediction boxes to calculate
    Recall and Precision values under different threshold conditions. Therefore, the number of boxes in the txt files
    under map_out/detection-results/ generated by this code is generally larger than that obtained by direct prediction.
    The purpose is to list all possible prediction boxes.
    '''
    #------------------------------------------------------------------------------------------------------------------#
    #   map_mode is used to specify what the file calculates when running
    #   map_mode = 0: Full mAP calculation process, including obtaining prediction results, ground truth boxes, and calculating VOC_map.
    #   map_mode = 1: Only obtain prediction results.
    #   map_mode = 2: Only obtain ground truth boxes.
    #   map_mode = 3: Only calculate map.
    #   map_mode = 4: Use the COCO toolbox to calculate the 0.50:0.95 mAP of the current dataset.
    #-------------------------------------------------------------------------------------------------------------------#
    map_mode        = 0
     #--------------------------------------------------------------------------------------#
    #   classes_path is used to specify the classes for which map needs to be calculated.
    #   Generally, it should be consistent with the classes_path used for training and prediction.
    #--------------------------------------------------------------------------------------#
    classes_path    = 'model_data/M3FD_classes.txt'
    MINOVERLAP      = 0.5
    #----------------------------------------------------------------------------------------------------------------------#
    #   Due to the principle of mAP calculation, the network needs to obtain nearly all prediction boxes to calculate mAP.
    #   Therefore, the confidence value should be set as small as possible to obtain all possible prediction boxes.
    #   
    #   This value is generally not adjusted. Because calculating mAP requires obtaining nearly all prediction boxes,
    #   the confidence defined here cannot be changed arbitrarily.
    #   To obtain Recall and Precision values under different thresholds, modify the score_threhold below.
    #----------------------------------------------------------------------------------------------------------------------#
    confidence      = 0.001
    #--------------------------------------------------------------------------------------#
    #   The value of non-maximum suppression (NMS) used during prediction. Larger values mean less strict NMS.
    #   This value is generally not adjusted.
    #--------------------------------------------------------------------------------------#
    nms_iou         = 0.5
    #---------------------------------------------------------------------------------------------------------------#
    #   Unlike AP (which is an area-based metric), Recall and Precision vary with the threshold.
    #   
    #   By default, the Recall and Precision values calculated in this code correspond to a threshold of 0.5
    #   Since calculating mAP requires obtaining nearly all prediction boxes, the confidence defined above cannot be changed arbitrarily.上
    #   A dedicated score_threhold is defined here to represent the threshold, so that the corresponding Recall and
    #   Precision values can be found when calculating mAP.
    #---------------------------------------------------------------------------------------------------------------#
    score_threhold  = 0.8
    #-------------------------------------------------------#
    #   map_vis is used to specify whether to enable visualization for calculation
    #-------------------------------------------------------#
    map_vis         = False
    #-------------------------------------------------------#
    #   Point to the folder where your dataset is located
    #   By default, it points to your dataset in the root directory
    #-------------------------------------------------------#
    dataset_path  = 'your_dataser/'
    #-------------------------------------------------------#
    #   Folder for outputting results, default is map_out
    #-------------------------------------------------------#
    map_out_path    = 'map_out'

    image_ids = open(os.path.join(dataset_path, "your_dataser/Main/val.txt")).read().strip().split()
    
    if not os.path.exists(map_out_path):
        os.makedirs(map_out_path)
    if not os.path.exists(os.path.join(map_out_path, 'ground-truth')):
        os.makedirs(os.path.join(map_out_path, 'ground-truth'))
    if not os.path.exists(os.path.join(map_out_path, 'detection-results')):
        os.makedirs(os.path.join(map_out_path, 'detection-results'))
    if not os.path.exists(os.path.join(map_out_path, 'images-optional')):
        os.makedirs(os.path.join(map_out_path, 'images-optional'))

    class_names, _ = get_classes(classes_path)

    if map_mode == 0 or map_mode == 1:
        print("Load model.")
        yolo = YOLO(confidence = confidence, nms_iou = nms_iou)
        print("Load model done.")

        print("Get predict result.")
        for image_id in tqdm(image_ids):
            
            #---------Special reminder: Please modify the image suffix to match the corresponding image ！！！
            image_path  = os.path.join(dataset_path, "clean/"+image_id+".png") # You can change the PNG suffix to the suffix of the dataset.
            #-----------------------------------------------------------------------------------------------
            
            image       = Image.open(image_path)
            if map_vis:
                
                #---------Special reminder: Please modify the image suffix to match the corresponding image ！！！
                image.save(os.path.join(map_out_path, "images-optional/" + image_id + ".png"))
                #-----------------------------------------------------------------------------------------------
                
            yolo.get_map_txt(image_id, image, class_names, map_out_path)
        print("Get predict result done.")
        
    if map_mode == 0 or map_mode == 2:
        print("Get ground truth result.")
        for image_id in tqdm(image_ids):
            with open(os.path.join(map_out_path, "ground-truth/"+image_id+".txt"), "w") as new_f:
                root = ET.parse(os.path.join(dataset_path, "Annotations/"+image_id+".xml")).getroot()
                for obj in root.findall('object'):
                    difficult_flag = False
                    if obj.find('difficult')!=None:
                        difficult = obj.find('difficult').text
                        if int(difficult)==1:
                            difficult_flag = True
                    obj_name = obj.find('name').text
                    if obj_name not in class_names:
                        continue
                    bndbox  = obj.find('bndbox')
                    left    = bndbox.find('xmin').text
                    top     = bndbox.find('ymin').text
                    right   = bndbox.find('xmax').text
                    bottom  = bndbox.find('ymax').text

                    if difficult_flag:
                        new_f.write("%s %s %s %s %s difficult\n" % (obj_name, left, top, right, bottom))
                    else:
                        new_f.write("%s %s %s %s %s\n" % (obj_name, left, top, right, bottom))
        print("Get ground truth result done.")

    if map_mode == 0 or map_mode == 3:
        print("Get map.")
        get_map(MINOVERLAP, False, score_threhold = score_threhold, path = map_out_path)
        print("Get map done.")

    if map_mode == 4:
        print("Get map.")
        get_coco_map(class_names = class_names, path = map_out_path)
        print("Get map done.")
